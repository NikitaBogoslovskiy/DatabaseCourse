# Лабораторная работа №11
Данная лабораторная работа довольно комплексная и включает в себя самые разные задания, поэтому в этот документ будут включены только два раздела: описание триггеров и примеры их написания. Выбор пал на тему триггеров, поскольку ей будет посвящен один из четырех номеров Контрольной работы №2. 

Примеры написания триггеров будут схожи с тем, что будет на контрольной работе, поэтому это одновременно и разбор триггеров, и рассмотрение типовых задач контрольной работы. 

## Триггеры
### Что это?
Когда мы создаем базу данных и даем к ней доступ на изменение какому-то человеку, сразу возникает вопрос доверия: вдруг он случайно или специально изменит данные так, как их не следует менять? Например, добавит товар с отрицательной ценой. Как фиксировать подобные изменения и не допускать их?

Для этого используют триггеры. В чем их смысл? Триггер - это та же процедура, выполняющая некоторую логику, но отличие состоит в том, что она автоматически запускается в определенные моменты времени. В частности, как мы помним, у нас есть три операции корректировки данных: добавление записи (insert), обновление записи (update) и удаление записи (delete). И триггер можно настроить так, чтобы он срабатывал до или после каких-то операций из этого списка. То есть у нас будет процедура с какой-то логикой, которая будет сама запускаться при попытке изменить таблицы. Там-то мы и можем проверить, насколько вносимые изменения корректны. 
 
### Как создать?
Нажимаем правой кнопкой мыши на вкладку `Triggers` и в выпадающем меню выбираем `New trigger`:

![](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab11/materials/create_trigger.jpg)

Далее мы переходим в жесткий режим программиста, чтобы писать триггер в виде кода (опять же, если вам удобнее настраивать процедуры и триггеры через графический интерфейс, то всегда пожалуйста - просто в рамках данного материала удобнее и понятнее демонстрировать решение в виде кода):

![](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab11/materials/compile.jpg)

Перед нами будет следующий код:
```sql
CREATE OR ALTER trigger new_trigger for 
active before insert position 0
AS
begin
  /* Trigger text */
end
```
Что мы здесь делаем? 

В первой строке `create or alter trigger new_trigger` мы определяем новый триггер с именем `new_trigger`, которое можно изменить в соответствии со своими нуждами - например, `my_first_trigger`. Дальше в этой же строке, в конце, мы можем заметить ключевое слово `for `: оно нужно для определения таблицы, изменения в которой мы будем фиксировать и обрабатывать. Например, мы хотим отлавливать все изменения таблицы `Operation`, тогда первая строка триггера примет вид:
```sql
CREATE OR ALTER trigger my_first_trigger for operation
```
Во второй строке `active before insert position 0` у нас целый набор слов, каждое из которых определяет поведение триггера:
1. Слово `active` отвечает за то, является ли данный триггер активным, то есть будет ли он вообще срабатывать - по умолчанию он активен, но если мы хотим его отключить, то всегда можно написать `inactive`.
2. Слово `before` определяет момент срабатывания триггера - когда мы запустим выполнение триггера, до внесения изменений в таблицу или после? По умолчанию стоит значение "до", но всегда можно определить срабатывание после, заменив `before` на `after`.
3. Слово `insert` определяет тип корректировки данных, на который срабатывает триггер. По умолчанию это добавление записи в таблицу, но может так же быть `update` и `delete`.
4. Выражение `position 0` определяет очередность срабатывания триггеров, которая может влиять на результат, если мы на один тип корректировки данных до или после поставим несколько триггеров. По умолчанию у всех триггеров нулевой номер в очереди (то есть они все стоят в самом начале). В рамках наших примеров мы не будем трогать это значение. 

По итогу, имеем следующую строку: 
```sql
active before insert position 0
```
Далее идет секция begin-end, в которой мы пишем содержание триггера - это мы уже рассмотрим подробнее на примерах.

В конце мы компилируем триггер, как обычную процедуру, и сохраняем его:

![](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab11/materials/compile.jpg)

### Какому плану будем следовать?
При написании процедур у нас был план, который состоял из двух частей - настройка процедуры и написание логики. Здесь все тоже самое, только внутренности этих частей поменяются.

Настройка триггера:
1. Определяем, для какой таблицы будет срабатывать триггер, и пишем ее название после ключевого слова `for`.
2. Определяем, когда будет срабатывать триггер - до внесения изменений (ключевое слово `before`) или после (ключевое слово `after`). 
3. Определяем, для какого типа изменений будет срабатывать триггер - `insert`, `update` и/или `delete` (если мы указываем несколько типов сразу, то тогда между ними ставится `or`).
4. Определяем, как будет называться триггер - как правило, название составляется следующим образом: `<первая буква порядка срабатывания><первая буква типа вносимых изменений>_<название таблицы>`. Например, мы определяем триггер, который будет срабатывать при вставке (`insert`) в таблицу (`Operation`) до внесения изменений (`before`) - тогда название примет вид `bi_operation` (before insert operation). Такие правила наименования необязательны, просто так проще ориентироваться в триггерах и том, что как они себя ведут.

Написание логики:
1. Решаем, что мы именно проверяем, то есть что пишем в проверочном условии `if`.
2. Решаем, как мы обрабатываем ситуацию, если проверка не прошла, то есть что пишем в `then`.

Настройка триггера будто уже совсем понятна, потому что подробно рассмотрена в этом разделе и предыдущем. Написание логики пока для нас абстрактно, поскольку что в прошлом разделе, что в этом мы опускаем детали. Давайте наконец посмотрим, как писать логику, то есть что у нас будет в секции begin-end.

## Примеры
Триггеры можно использовать для разных проверок и автоматизаций. В частности, мы будем обрабатывать следующие случаи:
1. Пользователь хочет добавить или изменить запись в таблице, используя какое-то некорректное значение - Пример 1.
2. Пользователь хочет внести изменения в таблицу, которая связана с другой таблицей - Пример 2.
3. Пользователь хочет добавить какой-то уникальный объект в таблицу, который в ней уже есть - Пример 3.
4. Пользователь не указывает явно значение какого-то атрибута, и нам нужно заполнить его дефолтным значением - Пример 4.

### Пример 1
Условие звучит следующим образом:

**Создать триггер, который при добавлении записи в таблицу OPERATION проверяет, что дата операции (OP_DATE) не больше текущей даты.**

Настройка триггера:
1. Мы обрабатываем внесение изменений в таблицу `Operation`, поэтому после ключевого слова `for` будет следовать `operation`.
2. Мы хотим выполнить проверку на корректность даты, чтобы, если дата плохая, запретить добавление новой записи в таблицу `Operation`. Если мы поставим эту проверку до добавления записи, то мы проверим дату, кинем исключение и на этом все - запись добавлена не будет. Если мы поставим эту проверку после, то мы добавим запись с плохой датой, выполним проверку, кинем исключение и брошенное исключение отменит все, что было выполнено раньше - в частности, добавление неправильной записи. Конечный результат один и тот же - новая запись с плохой датой не оказалась в таблице `Operation`. Но только при проверке до мы вообще не добавляем плохую запись, а при проверке после мы сначала ее добавляем, а потом удаляем. Второй подход затрачивает больше ресурсов, поскольку выполняет действия с таблицами, поэтому мы выберем первый подход - проверку до (`before`).
3. Определяем тип изменения данных - в условии идет речь о добавлении, поэтому выбираем тип `insert`.
4. Даем триггеру название. Поскольку мы запускаем триггер до (before, первая буква B), обрабатываем добавление записи в таблицу (insert, первая буква i) и работаем с таблицей операций (operation), назовем триггер `bi_operation`.

Тогда триггер примет вид:
```sql
CREATE OR ALTER trigger bi_operation for 
active before insert position 0
begin
  /* Ваш будущий код */
end
```

Написание логики:
1. Нужно проверить, что дата в новой добавляемой операции не превосходит текущую дату. Текущую дату можно получить, написав `current_date`. А вот чтобы получить добавляемую запись и ее атрибуты (`id_wh`, `id_ag`, `price` и т.д.), нужно обратиться к переменной `new`. `new` - это новая запись, которую пользователь пытается закинуть в `Operation`, и через точку мы можем обращаться к атрибутам этой записи, которые пользователь указал в запросе добавления `insert` (то есть `new.<имя_атрибута>`). Чтобы получить дату добавляемой операции, надо написать `new.op_date`, и тогда условие примет вид:
```sql
if (new.op_date > current_date) then
begin
  /* Код обработки ситуации, когда дата в записи все-таки больше текущей даты */
end
```
2. Нужно как-то обработать ситуацию добавления неправильной даты. Мы поступим так же, как поступали в [Лабораторной работе №9](https://github.com/NikitaBogoslovskiy/DatabaseCourse/tree/main/lab09), в [Задаче 3](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab09/task_3.md), в разделе [Проверка входных параметров](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab09/task_3.md#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0_%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85_%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2) - кинем исключение и в отдельной автономной транзакции запишем в таблицу `log_info` причину возникшей ошибки. То есть наше условие примет вид:
```sql
if (new.op_date > current_date) then
begin
  in autonomous transaction do
    insert into log_file(inform)
    values('Указанная дата больше текущей: ' || new.op_date);
  exception error;
end
```
На этом все. Мы настроили триггер и написали логику - теперь если плохой юзер попытается добавить операцию с плохой датой, данная операция добавлена не будет, а юзер, в свою очередь, получит исключение и сообщение об ошибке, чтобы в следующий раз писать только хорошие даты. 

Итоговый код:
```sql
CREATE OR ALTER trigger bi_operation for 
active before insert position 0
begin
  if (new.op_date > current_date) then
  begin
    in autonomous transaction do
      insert into log_file(inform)
      values('Указанная дата больше текущей: ' || new.op_date);
    exception error;
  end
end