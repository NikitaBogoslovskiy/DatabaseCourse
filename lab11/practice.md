# Примеры (практика)
Применение у триггеров может быть разное, но мы рассмотрим только некоторые. В частности, будут рассмотрены четыре примера, которые являются типовыми для Контрольной работы №2.

Навигация по решению:
* [Пример 1](#пример_1)
* [Пример 2](#пример_2)
* [Пример 3](#пример_3)
* [Пример 4](#пример_4)

<a name="пример_1"></a>
## Пример 1
Рассмотрим первое типовое применение триггера - отлавливание ошибок при изменении таблицы. Например, попытка добавления товара с отрицательной ценой или неверное указание даты операции. В таком случае мы должны кидать исключение и говорить человеку, где он ошибся.

Итак, условие задачи имеет вид:

**Создать триггер, который при добавлении записи в таблицу OPERATION проверяет, что дата операции (OP_DATE) не больше текущей даты.**

Сначала настроим триггер. Поскольку это первый пример, то комментарии при настройке будут более подробными - дальше пойдет все лаконичнее:
1. Хотя первый пункт по настройке - дать триггеру имя - мы его пропустим и поставим на четвертое место. Почему - узнаете в четвертом пункте :) А пока определим таблицу, изменения в которой будем отлавливать. Мы видим, что в условии речь идет про таблицу операций - `Operation` - поэтому тут все очевидно.
2. Определим тип операции, на который будет срабатывать триггер. Поскольку в условии идет речь о добавлении записи в таблицу, таким типом будет `insert`.
3. Определим порядок сработки - до или после изменений в таблице должен срабатывать триггер? Смотрите, тут интересный момент. Добавление записи в таблицу операций происходит следующим образом: `человек сделал insert-запрос` -> `сработали все before-триггеры для insert` -> `запись добавилась в таблицу, то есть сработала операция insert` -> `сработали все after-триггеры для insert`. Предположим, человек ввел косячную запись, в которой ошибка с датой. Где лучше кинуть исключение и сказать, что пользователь ошибся с вводом? Если мы сделаем это в before-триггере, то описанная выше цепочка добавления записи остановится на втором шаге, и до добавления записи в таблицу мы даже не дойдем. Если это сделать в after-триггере, то мы добавим запись, дойдем аж до четвертого шага и только там кинем исключение - оно приведет к отмене транзакции, и добавленная запись будет удалена. То есть конечный результат один и тот же - запись в таблице не окажется, так как она ошибочная, но только при втором подходе мы сначала добавим запись, а потом удалим. Кажется, что лучше пойти по пути наименьшего сопротивления и все решить до insert, то есть в before-триггере. Поэтому в данной задаче мы определим порядок сработки до - `before`.
4. Дадим триггеру наконец-то имя. Почему мы делаем это в конце? Дело в том, что имена у триггеров лучше делать "говорящими". Обычно они отражают суть триггера и составляются следующим образом: `<первая буква порядка сработки><первая буква типа операции>_<название таблицы>`. То есть в нашем случае названием примет вид `bi_operation`, где b - это `before`, i - `insert`.

Тогда код триггера будет следующим:
```sql
CREATE OR ALTER trigger bi_operation for operation
active before insert position 0
AS
begin
  /* Будущая логика */
end
```

Приступим к логике. Нам нужно проверить, является ли дата добавляемой операции больше текущей даты, и если да, то как-то на это отреагировать. Чтобы получить текущую дату, достаточно написать `current_date`. А вот чтобы получить дату добавляемой операции, нужно обратиться к внутренней переменной `new` - мы ее явно нигде не определяли, но она есть и хранит в себе атрибуты добавляемой записи, в том числе дату `op_date`. Тогда основное проверяющее условие примет вид:
```sql
if (new.op_date > current_date) then
begin
  /* Обработка случая, когда дата некорректная */
end
```
Обработка случая будет происходить так же, как мы это делали в [Лабораторной работе №9](https://github.com/NikitaBogoslovskiy/DatabaseCourse/tree/main/lab09), в [Задаче 3](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab09/task_3.md), в разделе [Проверка входных параметров](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab09/task_3.md#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0_%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85_%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2) - мы кинем исключение и в рамках отдельной автономной транзакции напишем в таблицу `log_file` сообщение об ошибке, то есть сделаем следующее:
```sql
in autonomous transaction do
  insert into log_file(inform)
  values('Добавляемая дата превосходит текущую: ' || new.op_date);
exception error;
```
Тогда итоговая реализация триггера примет вид:
```sql
CREATE OR ALTER trigger bi_operation for operation
active before insert position 0
AS
begin
  if (new.op_date > current_date) then
  begin
    in autonomous transaction do
      insert into log_file(inform)
      values('Добавляемая дата превосходит текущую: ' || new.op_date);
    exception error;
  end
end
```

<a name="пример_2"></a>
## Пример 2
Второе типовое применение триггеров - необходимость изменения связанной таблицы. Рассмотрим сразу на примере:

**Создать триггер, который при добавлении записи в таблицу OPERATION изменяет количество товара на соответствующем складе.**

Человек пытается добавить операцию по товару в таблицу `Operation`. Операция характеризует привоз или увоз товара с какого-то склада, следовательно, должно измениться количество этого товара на каком-то из складов. Это значит, что мы должны дополнительно изменить таблицу `Goods_WH`, обновив количество товара на складе в соответствии с добавляемой операцией. Ну что ж, приступим.

Настроим триггер:
1. Определим таблицу, изменения которой отлавливаются. По условию очевидно, что это `Operation`.
2. Определим тип операции, который мы учитываем. Речь идет о добавлении записи, поэтому тип `insert`.
3. Определим порядок сработки триггера - до или после. В контексте данной задачи разницы, по факту, нет - мы можем внести изменения в таблицу `Goods_WH` как до выполнения `insert`, так и после. Но в подобных задачах могут налагаться дополнительные ограничения. Например, если в таблице `Goods_WH` нет нужного товарного остатка или он есть, но изменение остатка приводит к отрицательному значению, то это может считаться некорректным вводом - и в таком случае нужно кинуть исключение и отменить операцию insert. Как уже было написано в [Примере 1](#пример_1) - если нам нужно кидать исключение и отменять операцию, лучше это делать до, в before-триггере. Поэтому для возможности будущего учета этих ограничений остановимся на `before`. Если хотите, то можете сами попробовать их учитывать.
4. Определим имя. Поскольку мы пишем before-триггер, обрабатывающий операцию `insert` в таблицу `Operation`, название примет вид `bi_operation`.

Код примет вид:
```sql
CREATE OR ALTER trigger bi_operation for operation
active before insert position 0
AS
begin
  /* Будущая логика */
end
```

Как видите, начало совпадает с [Примером 1](#пример_1), поэтому мы можем либо написать новый триггер с другим названием (настройки у него будут те же), либо написать логику нашего триггера в уже существующем `bi_operation`, просто писать надо будет ниже уже имеющегося кода в секции begin-end.

Какая будет логика? Тут все очень просто. Если у операции тип `A`, то мы должны увеличить товарные остатки, потому что товар привезли на склад, его стало больше. Если тип `R`, то уменьшить остатки, потому что товар увезли, его стало меньше. Тогда код примет вид:
```sql
if (new.typeop = 'A') then
  update goods_wh
  set quantity = quantity + new.quantity
  where id_goods = new.id_goods and id_wh = new.id_wh;
else if (new.typeop = 'R') then
  update goods_wh
  set quantity = quantity - new.quantity
  where id_goods = new.id_goods and id_wh = new.id_wh;
```
То есть что мы делаем. Если тип у добавляемой операции `A`, то мы обращаемся к таблице `Goods_WH` на изменение (`update`), находим запись, которая соответствует товару и складу из операции с помощью `where` и к уже имеющемуся количеству добавляем количество, указанное в операции - то есть сколько привезли на склад. Если тип операции `R`, то мы делаем ровно тоже самое, только количество не увеличивается, а уменьшается - товар со склада увозят. 

Итоговый код примет вид:
```sql
CREATE OR ALTER trigger bi_operation for operation
active before insert position 0
AS
begin
  if (new.typeop = 'A') then
    update goods_wh
    set quantity = quantity + new.quantity
    where id_goods = new.id_goods and id_wh = new.id_wh;
  else if (new.typeop = 'R') then
    update goods_wh
    set quantity = quantity - new.quantity
    where id_goods = new.id_goods and id_wh = new.id_wh;
end
```

<a name="пример_3"></a>
## Пример 3
Третье применение триггера - обработка совпадений. Есть таблицы, в которых не может быть двух объектов с одинаковыми именами. Например, в таблице товаров `Goods` не может быть двух папок. Если человек хочет добавить что-то неуникальное в таблицу, где все должно быть уникальным - мы не даем ему этого сделать.

Собственно, условия типовой задачи:

**Создать триггер, который при добавлении склада проверяет, что склада с таким названием еще нет в таблице.**

Настройка процедуры:
1. Название таблицы. Речь идет о таблице со складами, поэтому мы отлавливаем изменения таблицы `Warehouse`.
2. Тип операции. В задаче говорится про добавление, поэтому тип операции - `insert`.
3. Порядок сработки триггера. Ситуация аналогична [Примеру 1](#пример_1) - мы обрабатываем, по факту, некорректный ввод. Поэтому остановимся на обработке до - `before`.
4. Название триггера - `bi_warehouse`, то есть `before insert warehouse`.

Код примет вид:
```sql
CREATE OR ALTER trigger bi_warehouse for warehouse
active before insert position 0
AS
begin
  /* Будущая логика */
end
```

Приступим к логике. Нам надо проверить, что добавляемого склада еще нет в таблице `Warehouse` - а если есть, то бросить исключение. Будем считать, что у нового склада должны быть новые id и название, то есть атрибуты `id_wh` и `name`. Условие, которое будет проверять это, может быть записано следующим образом:
```sql
if ((select count(id_wh)
     from warehouse
     where id_wh = new.id_wh or name = new.name) > 0) then
begin
  /* Обработка случая совпадения id или названия */ 
end
```
Что мы здесь делаем? Мы прямо в условии делаем запрос, в котором ищем количество записей в таблице `Warehouse`, совпадающих с новой добавляемой записью по id или названию. Если таких записей больше, чем ноль, то, значит, добавляемый склад неуникален и эту ситуацию нужно как-то обработать.

Мы будем поступать так же, как и раньше - бросать исключение и делать запись в таблицу `log_file` с сообщением об ошибке:
```sql
if ((select count(id_wh)
     from warehouse
     where id_wh = new.id_wh or name = new.name) > 0) then
begin
    in autonomous transaction do
      insert into log_file(inform)
      values('Уже есть склады, имеющие введенные id и/или название: id = '
      || new.id_wh || ', название = ' || new.name);
    exception error; 
end
```
Ну, вот и все. Обработка неуникальности сделана, и тогда итоговый код триггера будет иметь следующий вид:
```sql
CREATE OR ALTER trigger bi_warehouse for warehouse
active before insert position 0
AS
begin
  if ((select count(id_wh)
       from warehouse
       where id_wh = new.id_wh or name = new.name) > 0) then
  begin
    in autonomous transaction do
      insert into log_file(inform)
      values('Уже есть склады, имеющие введенные id и/или название: id = '
      || new.id_wh || ', название = ' || new.name);
    exception error;
  end
end
```

<a name="пример_4"></a>
## Пример 4
Четвертое и последнее в рамках данного материала типовое применение триггера - установка дефолтных значений (значений по умолчанию, default). Перейдем сразу к условию задачи:

**Создать триггер, который проверяет, задана ли дата операции (OP_DATE). И если нет, указывает текущую дату.**

В таблицах бывают атрибуты, которые необязательны к заполнению и могут принимать null-значения. Какие именно атрибуты, можно посмотреть в свойствах таблицы. Дата у операции необязательна к заполнению, поэтому человек при добавлении новой записи может спокойно указать `null` вместо даты. Задача требует от нас, чтобы в таком случае мы ставили какое-то значение по умолчанию, чтобы в таблице не было null-значений. В частности, это должна быть текущая дата. 

Ну, сначала, как всегда, настроим триггер:
1. Название таблицы - `Operation`.
2. Тип операции - `insert`, поскольку мы обрабатываем добавление записи.
3. Порядок сработки триггера. В этой задаче у нас только один вариант - до - потому что мы должны решить до вставки, что пойдет в `Operation`: какая-то реальная дата или дефолтное значение. Выбираем `before`.
4. Имя триггера, не сложно догадаться - `bi_operation`.

Аналогично с [Примером 3](#пример_3), мы можем либо написать новый триггер с другим названием для этой задачи, либо добавить нашу логику в уже существующий триггер `bi_operation`. Так просто складывается, что мы почти во всех задачах обрабатываем вставку в таблицу `Operation` в режиме `before` :)

Код тогда примет уже знакомый нам вид:
```sql
CREATE OR ALTER trigger bi_operation for operation
active before insert position 0
AS
begin
  /* Будущая логика */
end
```

Приступим к логике. Здесь она очень простая: если атрибут `op_date` новой записи `new` имеет null-значение, то тогда этот атрибут должен получить значение текущей даты `current_date`, то есть:
```sql
if (new.op_date is null) then
  new.op_date = current_date;
```
Не поверите - это все. Итоговый код триггера будет выглядеть следующим образом:
```sql
CREATE OR ALTER trigger bi_operation for operation
active before insert position 0
AS
begin
  if (new.op_date is null) then
    new.op_date = current_date;
end
```
Если вы дошли до этого места и не сломались, то я искренне горжусь вами - вы большие молодцы. 
