# Лабораторная работа №10
В данной лабораторной работе мы познакомимся с курсорами. 

Навигация по документу:
1. [Теория](#теория)
    1. [Явный курсор](#явный_курсор)
    2. [Неявный курсор](#неявный_курсор)
2. [Практика](#практика)
   1. [Задача №1](#задача_1) 

<a name="теория"></a>
## Теория
Курсоры позволяют в цикле обрабатывать таблицы, то есть работать с ними итерационно, построчно. Курсоры бывают явными и неявными. 

<a name="явный_курсор"></a>
### Явный курсор
Что есть **явный** курсор и как с ним работать? Для того чтобы ввести его в процедуру, необходимо объявить его явно в том же месте, где объявляются локальные переменные:
```sql
create or alter procedure my_procedure (
    /* Объявление входных аргументов */)
returns (
    /* Объявление выходных аргументов */)
as
/* Объявление локальных переменных */
declare cursor_name cursor for (/* SQL-запрос */);
begin
  /* Код функции */
end
```
В графическом интерфейсе он объявляется в следующей секции:
![](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab10/materials/cursors_gui.jpg)

Курсор объявляется для некоторого SQL-запроса, который при выполнении возвращает таблицу. Важно, что если в операторе select находятся какие-то вычисления, соответствующие столбцы должны иметь явные имена. Например, если у нас есть такой запрос:
```sql
select count(*)
from operation
```
То для столбца, хранящего количество записей в таблице `Operation`, необходимо использовать алиас (псевдоним). Тогда запрос примет следующий вид:
```sql
select count(*) as operations_number
from operation
```
Когда запрос выполнится, с помощью курсора мы сможем в цикле ходить по получившейся таблице. Как, собственно, выглядит цикл? Давайте посмотрим:
```sql
open cursor_name;
while (true) do
begin
  fetch cursor_name into :variable_1, :variable_2, ..., :variable_n;
  if (row_count = 0) then
      leave;
  suspend; /* или какая-то логика */
end
close cursor_name;
```
Что мы здесь делаем:
1. Сначала открываем курсор для итерационного построчного чтения таблицы. 
2. Начинаем бесконечный цикл.
3. В теле цикла с помощью оператора `fetch` извлекаем текущую запись таблицы, на которую указывает курсор, и сохраняем атрибуты этой записи в переменные `:variable_1`, `:variable_2`, ..., `:variable_n`. После вызова `fetch` курсор смещается на следующую запись. 
4. В условии с `row_count = 0` мы проверяем, оставались ли при последнем `fetch` еще строки на чтение. Если нет, то, значит, курсор достиг конца и можно прерывать цикл с помощью оператора `leave`. Если да, то тогда двигаемся по циклу дальше. 
5. Если переменные являются выходными, то тогда нужно вызвать suspend, чтобы текущие значения переменных (то есть значение текущей записи в таблице) были переданы во внешний контекст. Если переменные локальные и нужны для чего-то другого, то вместо suspend может следовать логика, использующая каким-то образом эти переменные.
6. После завершения цикла курсор необходимо закрыть.

В некоторых задачах мы можем захотеть изменять или удалять записи, на которые указывает курсор. Для этого можно использовать конструкцию `where current of cursor_name`. Например, мы идем циклом по таблице `Operation` и хотим обнулить цену по операции, на которую сейчас указывает курсор - тогда надо сделать следующее
```sql
update operation
set price = 0
where current of cursor_name;
```

<a name="неявный_курсор"></a>
### Неявный курсор
А как выглядит **неявный** курсор? До этого мы уже работали с циклами for и ходили итеративно по таблицам, получавшимся в результате SQL-запросов - так вот в рамках данного цикла можно также ввести курсор, он будет называться неявным:
```sql
for /* SQL-запрос, возвращающий таблицу */
    as cursor cursor_name do
begin
    /* Какой-то код */
end
```
Какими преимуществами обладает такой курсор?
1. Его не нужно объявлять в отдельной секции.
2. По-прежнему работает конструкция `where current of`.
3. Для получения атрибутов записи, на которую указывает курсор, не нужно применять оператор `fetch` и сохранять атрибуты в переменные, как мы это делали с явным курсором - здесь доступна опция обращения к атрибутам текущей записи через точку. То есть если мы идем в цикле по таблице `Operation` и хотим узнать значение атрибута `price` у записи, на которую указывать курсор `cursor_name`, достаточно сделать следующее: `cursor_name.price`.

<a name="практика"></a>
## Практика

<a name="задача_1"></a>
### [Задача №1](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab10/task_1.md)
В этом блоке описано решение первой задачи.
