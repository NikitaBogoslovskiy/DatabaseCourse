# Задача №7
Условие звучит следующим образом:

**Для заданных названия таблицы (TNAME) и названиям двух
столбцов (ST1_NAME, ST2_NAME) выдать информацию из 
таблицы TNAME, сгруппированную по первому столбцу 
ST1_NAME, с указанием минимального и максимального 
значений во втором столбце ST2_NAME**

Особенность этой задачи заключается в том, что нам не дают каких-то конкретных входных данных, как раньше - название, дата, количество или что-то еще. Сейчас нам дают название таблицы и столбцов в строковом виде. То есть мы не знаем заранее, с какой таблицей нам придется работать и что за атрибуты будут в ней. Это дает нашей процедуре универсальность - она может выполнять однотипную задачу для разных таблиц и столбцов.

В данной задаче от нас просят сделать следующее. Нам нужно сформировать универсальный запрос, который сможет в таблице `TNAME` выполнить группировку по столбцу `ST1_NAME` и для каждой группы вывести минимальное и максимальное значение столбца `ST2_NAME`. Например, пусть пользователь в качестве `TNAME` взял таблицу `Operation`, в качестве `ST1_NAME` взял столбец с id-шниками складов `id_wh`, в качестве `ST2_NAME` взял столбец с ценами `price`. Тогда наша процедура будет решать задачу группировки всех операций по складам и вывода минимальной и максимальной цен для каждой группы операций. Аналогично можно придумать еще несколько примеров, которые будут решаться с помощью одной и той же процедуры, которую мы собираемся реализовать. Это ж круто!

Приступим к созданию процедуры по стратегии из документа ["Как писать процедуры?"](https://github.com/NikitaBogoslovskiy/DatabaseCourse/tree/main/lab09/how-to-create-procedures.md).  

Навигация по решению:

1. [Настройка процедуры](#настройка_процедуры)
2. [Написание логики](#написание_логики)
3. [Итоговый код процедуры](#итоговый_код_процедуры)

<a name="настройка_процедуры"></a>
## Настройка процедуры
1. Дадим процедуре имя `group_and_find_minmax`, то есть "сгруппировать и найти минимум и максимум".
2. Добавим ей входные параметры. Из условия можно видеть, что нам на вход дают три параметра - название таблицы `TNAME`, название первого столбца `ST1_NAME`, название второго столбца `ST2_NAME`. Поскольку, названия - это, по факту, строки, тип у всех переменных будет строковый. Предположим, что длина названий не превышает 50 символов, тогда можно использовать тип `varchar(50)` (то есть строка переменной длины, которая не должна превышать значения 50). 
3. Локальные переменные. Оставим пока эту секцию пустой.
4. Выходные параметры. По итогу, мы хотим получить таблицу с тремя столбцами: первый будет содержать значение атрибута `ST1_NAME` для каждой группы, второй будет хранить минимальные значения атрибута `ST2_NAME` для каждой группы, третий будет хранить максимальные значения этого же атрибута. Поскольку мы не можем заранее узнать, какие типы будут у этих столбцов, дадим выходным параметрам также строковый тип - тогда мы сможем выводить любые значения. Если столбцы `ST1_NAME` или `ST2_NAME` имели числовой тип, то число будет приведено к строке. Если столбцы имели тип даты, дата так же будет записана в виде строки. Если столбцы имели строковый тип, то тогда все останется без изменений. Аналогично входным параметрам возьмем тип `varchar(50)`. Назовем столбец с сгруппированными значениями столбца `ST2_NAME` - `st2_value`, столбец со минимальными значениями `ST2_NAME` - `st2_min`, столбец с максимальными значениями `ST2_NAME` - `st2_max`.

Тогда процедура примет следующий вид:
```sql
create or alter procedure group_and_find_minmax (
    tname varchar(50),
    st1_name varchar(50),
    st2_name varchar(50))
returns (
    st2_value varchar(50),
    min_value varchar(50),
    max_value varchar(50))
as
begin
  /* Будущий код */
end
```

<a name="написание_логики"></a>
## Написание логики
1. Проверка входных параметров. Поскольку входные параметры нам неизвестны, и мы знаем только, что это строки, проверять особо нечего. Этот этап можно пропустить.
2. Решение основной задачи. 
Нам нужно написать запрос, который в таблице `st1_name` будет выполнять группировку по `st2_name` и искать минимальные и максимальные значения этого атрибута. Поскольку название таблицы и названия столбцов даны нам в виде строк, напрямую в запросе мы их использовать не можем. То есть нам нельзя написать такой вот запрос (приведен для примера):
```sql
select :st1_name, :st2_name
from :tname
```
Но что мы можем сделать? Раз входные параметры у нас строковые, так давайте сделаем весь запрос строковым. То есть:
```sql
'select ' || :st1_name || ', ' || :st2_name
' from ' || :tname
```
По смыслу это то же самое, что и выше, только в виде строки. Оператор конкатенации `||` позволяет нам объединить ключевые слова запроса select и from с названиями таблицы и столбцов. 

Сформируем теперь искомый запрос. Нам нужно выполнить в таблице `tname` группировку по `st1_name` и вывести минимальное и максимальное значение `st2_name` для каждой группы. В обычном виде это имело бы вид:
```sql
select :st1_name, min(:st2_name), max(:st2_name)
from :tname
group by :st1_name
```
Однако раз нам нужна строка, запрос примет следующую форму:
```sql
'select ' || :st1_name || ', min(' || :st2_name || '), max(' || :st2_name || ')'  ||
' from ' || :tname || 
' group by ' || :st1_name;
```

## Вывод результирующей таблицы
Этот строковый запрос надо как-то запустить. Для этого объявим вспомогательную строковую переменную переменной длины не больше 200:
```sql
declare variable operation varchar(200);
```
И запишем в нее сформированный строковый запрос:
```sql
:operation = 'select ' || :st1_name || ', min(' || :st2_name || '), max(' || :st2_name || ')'  ||
             ' from ' || :tname || 
             ' group by ' || :st1_name;
```
Чтобы запустить запрос, представленный в виде текста, можно воспользоваться командой `execute statement` (по факту, это эквивалентно выполнению обычного запроса, записанного не через строку):
```sql
execute statement :operation
```

В результате мы получим таблицу, которую нужно как-то передать внешнему контексту. Мы уже рассматривали подобную построковую передачу таблицы с помощью цикла for в [Задаче №3](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab09/task_3.md), в пункте ["2.iii. Вывод результирующей таблицы"](https://github.com/NikitaBogoslovskiy/DatabaseCourse/blob/main/lab09/task_3.md#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4_%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B5%D0%B9_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B). Здесь все то же самое, только мы проходимся циклом for не по стандартному запросу, а по выполнению текстового запроса:
```sql
for execute statement :operation 
into :st2_value, :st2_min, :st2_max 
do suspend;
```
Как итог, мы передаем таблицу наружу и успешно завершаем выполнение процедуры. Тогда итоговый код процедуры примет вид, описанный ниже.

<a name="итоговый_код_процедуры"></a>
## Итоговый код процедуры
```sql
create or alter procedure group_and_find_minmax (
    tname varchar(50),
    st1_name varchar(50),
    st2_name varchar(50))
returns (
    st2_value varchar(50),
    min_value varchar(50),
    max_value varchar(50))
as
declare variable operation varchar(200);
begin
  :operation = 'select ' || :st1_name || ', min(' || :st2_name || '), max(' || :st2_name || ')'  ||
               ' from ' || :tname || 
               ' group by ' || :st1_name;
  for execute statement :operation 
  into :st2_value, :st2_min, :st2_max 
  do suspend;
end
```